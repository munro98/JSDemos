<!DOCTYPE html>
<html>

<head>
  <title>Boids</title>
  <script>


    class Boid {

      constructor(swarm) {

        this.x = Math.random() * swarm.width;
        this.y = Math.random() * swarm.height;
        this.heading = Math.random() * 2 * Math.PI - Math.PI;

      }

      draw(ctx) {
        let pointLen = this.radius * 2.5;
        ctx.fillStyle = 'blue';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(this.x + Math.cos(this.heading + Math.PI / 2) * this.radius,
          this.y + Math.sin(this.heading + Math.PI / 2) * this.radius);
        ctx.lineTo(this.x + Math.cos(this.heading + Math.PI) * pointLen,
          this.y + Math.sin(this.heading + Math.PI) * pointLen);
        ctx.lineTo(this.x + Math.cos(this.heading - Math.PI / 2) * this.radius,
          this.y + Math.sin(this.heading - Math.PI / 2) * this.radius);
        ctx.fill();
      }

      distance(boid, width, height) {
        let x0 = Math.min(this.x, boid.x),
          x1 = Math.max(this.x, boid.x);
        let y0 = Math.min(this.y, boid.y),
          y1 = Math.max(this.y, boid.y);
        let dx = Math.min(x1 - x0, x0 + width - x1);
        let dy = Math.min(y1 - y0, y0 + height - y1);
        return Math.sqrt(dx * dx + dy * dy);
      }

      getNeighbors(swarm) {
        let w = swarm.width,
          h = swarm.height;
        let neighbors = [];
        for (let i = 0; i < swarm.boids.length; i++) {
          let boid = swarm.boids[i];
          if (this !== boid && this.distance(boid, w, h) < this.vision) {
            neighbors.push(boid);
          }
        }
        return neighbors;
      }

      wrap(value) {
        let min, max;
        if (arguments.length === 2) {
          min = 0;
          max = arguments[1];
        } else if (arguments.length === 3) {
          min = arguments[1];
          max = arguments[2];
        }
        while (value >= max) value -= (max - min);
        while (value < min) value += (max - min);
        return value;
      }


      clamp(value, limit) {
        return Math.min(limit, Math.max(-limit, value));
      }

      meanAngle() {
        let sumx = 0,
          sumy = 0,
          len = arguments.length;
        for (let i = 0; i < len; i++) {
          sumx += Math.cos(arguments[i]);
          sumy += Math.sin(arguments[i]);
        }
        return Math.atan2(sumy / len, sumx / len);
      }

      update(swarm) {
        let w = swarm.width,
          h = swarm.height;
        let neighbors = this.getNeighbors(swarm);
        if (neighbors.length > 0) {
          let meanhx = 0,
            meanhy = 0;
          let meanx = 0,
            meany = 0;
          let mindist = this.radius * 2,
            min = null;
          for (let i = 0; i < neighbors.length; i++) {
            let boid = neighbors[i];
            meanhx += Math.cos(boid.heading);
            meanhy += Math.sin(boid.heading);
            meanx += boid.x;
            meany += boid.y;
            let dist = this.distance(boid, w, h);
            if (dist < mindist) {
              mindist = dist;
              min = boid;
            }
          }
          meanhx /= neighbors.length;
          meanhy /= neighbors.length;
          meanx /= neighbors.length;
          meany /= neighbors.length;

          let target;
          if (min) {
            // Move away
            target = Math.atan2(this.y - min.y, this.x - min.x);
          } else {
            // Move towards center
            let meanh = Math.atan2(meanhy, meanhx);
            let center = Math.atan2(meany - this.y, meanx - this.x);
            target = this.meanAngle(meanh, meanh, meanh, center);
          }

          let delta = this.wrap(target - this.heading, -Math.PI, Math.PI);
          delta = this.clamp(delta, this.radialSpeed);
          this.heading = this.wrap(this.heading + delta, -Math.PI, Math.PI);
        }

        this.move(swarm);
      }

      move(swarm) {
        let padding = swarm.padding;
        let width = swarm.width,
          height = swarm.height;
        this.x = this.wrap(this.x + Math.cos(this.heading) * this.speed, -padding, width + padding * 2);
        this.y = this.wrap(this.y + Math.sin(this.heading) * this.speed, -padding, height + padding * 2);
      }

    }

    Boid.radius = 6;
    Boid.speed = 2;
    Boid.radialSpeed = Math.PI / 60;
    Boid.vision = 50;

    class Swarm {
      constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = canvas.getContext('2d');

        this.boids = [];
        let swarm = this;
        this.padding = 8;
      }

      createBoid(n) {
        for (let i = 0; i < n; i++) {
          this.boids.push(new Boid(this));
        }
      }

      clear() {
        this.boids = [];
      }

      update() {

        console.log("up" + this.boids.length);

        if (canvas.width != window.innerWidth)
          canvas.width = window.innerWidth;
        if (canvas.height != window.innerHeight)
          canvas.height = window.innerHeight;

        this.ctx = canvas.getContext('2d');
        this.ctx.fillStyle = 'white';
        this.ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let i = 0; i < this.boids.length; i++) {
          this.boids[i].update(this);
          this.boids[i].draw(this.ctx);
        }
      }


    }

    let swarm;
    function update() {
      swarm.update();
    }

    window.onload = function (e) {

      console.log("loaded");

      swarm = new Swarm();
      swarm.id = setInterval(update, 33);
      swarm.createBoid(100);
    };

  </script>
</head>

<body>
  <canvas id="canvas" width="640" height="640" style="position: absolute; left: 0; top: 0;">
  </canvas>
</body>

</html>